<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>John Lalor</title><link href="http://jplalor.github.io/" rel="alternate"></link><link href="http://jplalor.github.io/feeds/irt.atom.xml" rel="self"></link><id>http://jplalor.github.io/</id><updated>2019-02-12T00:00:00-05:00</updated><entry><title>Item Response Theory for Natural Language Processing</title><link href="http://jplalor.github.io/emnlp-16.html" rel="alternate"></link><updated>2019-02-12T00:00:00-05:00</updated><author><name>John Lalor</name></author><id>tag:jplalor.github.io,2019-02-12:emnlp-16.html</id><summary type="html">&lt;p&gt;This post is meant as a companion to our EMNLP 2016 paper &lt;a href="https://arxiv.org/abs/1605.08889"&gt;"Building an Evaluation Scale using Item Response Theory"&lt;/a&gt;. 
It's quite a bit overdue, but hopefully this post will be useful to those who haven't seen IRT before.&lt;/p&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Let's start by thinking about the typical supervised machine learning setup. 
There is some training data, a held-out test set, and a machine learning model.
The goal is to use the training data to learn a model that performs well on the test set.
"Performs well"" is usually measured by some aggregate statistic such as accuracy, precision/recall, etc.
These aggregate statistics assume that each test set example is as important in determining model performance as every other test set example.
But what if that isn't the case?
What if certain examples are so easy that labelling them incorrectly is disastrous?
Or on the other hand, what if certain examples are so hard that no model labels them correctly (except your new deep deep deep network)?&lt;/p&gt;
&lt;p&gt;Characteristics such as difficulty are often used to assess humans in psychometrics, specifically a method known as Item Response Theory (IRT).
The high-level idea with IRT is that if you have enough test-takers providing answers to questions on a test ("items,"" hence the Item in IRT), you can learn latent parameters of the items as well as estimate a latent ability trait of the test-takers themselves.
IRT is popular in standardized tests such as the SAT and the GMAT.
It's used to assess the test-takers but also to select appropriate items for the tests themselves (if a test question is too easy, there's no need to include it).
What we wanted to do was take the IRT methodology and apply it to machine learning models, specifically models trained to do the natural language processing (NLP) natural language inference (NLI) task.&lt;/p&gt;
&lt;h1&gt;IRT&lt;/h1&gt;
&lt;p&gt;The key driver behind IRT is what's known as the Item Characteristic Curve (ICC).
Each item has an associated ICC, which can take certain forms depending on the IRT model that you're looking at.
A popular model (and the one we used in our paper) is the 3 Parameter Logistic (3PL) model:&lt;/p&gt;
&lt;div class="math"&gt;$$
p_{ij}(\theta_j) = c_i + \frac{1 - c_i}{1 + e^{-a_i(\theta_j - b_i)}}
$$&lt;/div&gt;
&lt;p&gt;
Here, &lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt; is the latent ability parameter of test-taker &lt;span class="math"&gt;\(j\)&lt;/span&gt;, and &lt;span class="math"&gt;\(a_i\)&lt;/span&gt;, &lt;span class="math"&gt;\(b_i\)&lt;/span&gt;, and &lt;span class="math"&gt;\(c_i\)&lt;/span&gt; are item &lt;span class="math"&gt;\(i\)&lt;/span&gt;'s discriminatory, difficulty, and guessing parameters, respectively.
A typical IRT curve will look something like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="plot of chunk irtplot1" src="http://jplalor.github.io/figure/emnlp16-irtplot1-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;Our x-axis is &lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt;, the latent ability parameter.
The y-axis is &lt;span class="math"&gt;\(p_{ij}(\theta_j)\)&lt;/span&gt;, the probability that an individual with a certain ability level will answer this item correctly.
The curve is monotonically increasing, which makes sense. 
As the ability of an individual increases, we expect that the probability of that individual answering correctly will also increase.
&lt;span class="math"&gt;\(a_i\)&lt;/span&gt;, the discriminatory parameter, represents the slope of the curve at its steepest point.
&lt;span class="math"&gt;\(a_i\)&lt;/span&gt; should be steep enough that in a relatively short range, there is a sizeable jump in &lt;span class="math"&gt;\(p_{ij}(\theta_j)\)&lt;/span&gt;, but shouldn't be so steep that the range is tiny.
An item with too steep of a slope is only useful in a very small ability range:&lt;/p&gt;
&lt;p&gt;&lt;img alt="plot of chunk irtplot2" src="http://jplalor.github.io/figure/emnlp16-irtplot2-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(b_i\)&lt;/span&gt;, the difficulty parameter, represents the halfway point between the minimum and maximum values of &lt;span class="math"&gt;\(p_{ij}(\theta_j)\)&lt;/span&gt;.
For a 3PL model, the minimum is &lt;span class="math"&gt;\(c_i\)&lt;/span&gt; and the maximum is &lt;span class="math"&gt;\(1\)&lt;/span&gt;.
Since &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; is a unit Gaussian (&lt;span class="math"&gt;\(\theta_j \sim N(0, 1)\)&lt;/span&gt;), we want the value of &lt;span class="math"&gt;\(b_i\)&lt;/span&gt; to fall somewhere between &lt;span class="math"&gt;\(-3\)&lt;/span&gt; and &lt;span class="math"&gt;\(3\)&lt;/span&gt; in most cases, since that covers 99.7% of people.
The next two plots show "easy"" and "hard"" items where the difficulty parameters are &lt;span class="math"&gt;\(-2\)&lt;/span&gt; and &lt;span class="math"&gt;\(2\)&lt;/span&gt;, respectively:&lt;/p&gt;
&lt;p&gt;&lt;img alt="plot of chunk irtplot3" src="http://jplalor.github.io/figure/emnlp16-irtplot3-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="plot of chunk irtplot4" src="http://jplalor.github.io/figure/emnlp16-irtplot4-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(c_i\)&lt;/span&gt; is referred to as the guessing parameter. As you can see from the plots above, the lower asymptotes of the curves are not &lt;span class="math"&gt;\(0\)&lt;/span&gt;. In a three parameter model, there is an assumption that even at low levels of &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, there is some non-zero probability that an individual will answer a question correctly (with for example a lucky guess). That is modeled by &lt;span class="math"&gt;\(c_i\)&lt;/span&gt;.&lt;/p&gt;
&lt;h1&gt;IRT for NLP&lt;/h1&gt;
&lt;p&gt;So how can we use IRT to help us in NLP? 
It's often the case that when you train and test your brand new machine learning model on an NLP dataset, the metric of interest is test set accuracy. 
If your model has a higher accuracy than the current state of the art in the literature, then your model becomes the new benchmark against which other models are evaluated. 
However, there is usually something missing in these evaluations: the question of the specific test set examples that were answered correctly. 
If your fancy new model has a high accuracy because it labeled a random sequence of examples correctly, that indicates very different performance than some other model that labeled items correctly according to their difficulty (i.e. labeled all easy examples correctly up to some difficulty threshold, then labeled all subsequent examples incorrectly). 
Having some notion of difficulty is important to distinguish between these two cases, which is where IRT comes in!&lt;/p&gt;
&lt;p&gt;We decided to test this out on the Stanford Natural Language Inference (SNLI) dataset. Natural language inference (NLI) is a popular task in NLP, where the goal is to determine if some sentence (premise) entails some other sentence (hypothesis). If the premise is true, does that mean that the hypothesis must be true (entailment), cannot be true (contradiction), or could be either (neutral)? You can imagine that there might be some ambiguity about certain examples having certain labels. So this seems like a perfect place to apply IRT to see if we can learn anything about the data and the high-performing models trained on the dataset.&lt;/p&gt;
&lt;h1&gt;Data Collection&lt;/h1&gt;
&lt;p&gt;In order to fit these IRT models, you need a lot of data. Specifically, you need a lot of answers to the same set of questions. If you ask a lot of people to take the same test, then grade each of their answers, the graded responses for each person is that person's response pattern. With a set of response patterns you can fit an IRT model to learn the latent parameters of the items as well as the latent &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; for each of the test-takers.&lt;/p&gt;
&lt;p&gt;This goes against what is typically done when you are gathering data for machine learning models. Usually, you will collect between one and five labels for each example in your data set, and use a majority vote to determine the gold standard. Here, we used the crowdsourcing platform Amazon Mechanical Turk to gather 1000 labels for each example from our SNLI subset. So instead of asking a lot of Turkers for a few labels to a lot of examples, we asked them for a lot of labels for a small number of examples. Each Turker provided a label for each example, so we were able to grade the Turker responses to generate response patterns.&lt;/p&gt;
&lt;h1&gt;IRT Analysis&lt;/h1&gt;
&lt;p&gt;Fitting an IRT model is a cyclical process. At a high level, you fit your model, using your software package of choice (for R, the &lt;em&gt;mirt&lt;/em&gt; package is a good one). Then you check how well each item fits in with the learned model. Are there items where the discriminatory parameter is too large? Items like these aren't useful outside of a very specific range so they can be removed. Items where the parameter is too small are also removed, because they are not able to discriminate at all. Are there items that violate the local independence assumption? These are also removed.
Typically the items are removed one at a time, the model is re-fit, and the set of items is checked again. &lt;/p&gt;
&lt;h1&gt;Results&lt;/h1&gt;
&lt;p&gt;There are a number of results in the paper, but to boil it down into a single takeaway: specific data points are important! If you are testing your model on an easy dataset, then high accuracy scores aren't all that impressive, because everyone has a high accuracy. On the other hand, if you test on a difficult dataset, then lower accuracy scores may be indicative of higher latent &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, since the score is with respect to some population of test-takers. &lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Hopefully this was a useful introduction to IRT. I encourage you to check out the paper for much more detail. And feel free to email me if you have any questions or comments. The next post will discuss our EMNLP 2018 paper: Understanding Deep Learning Performance through an Examination of Test Set Difficulty: A Psychometric Case Study.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="ml"></category><category term="nlp"></category><category term="irt"></category></entry></feed>